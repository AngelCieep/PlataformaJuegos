{% extends 'layout.html.twig' %}

{% block title %}Tetris{% endblock %}

{% block page_content %}
<style>
    body {
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        font-family: 'Arial', sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
    }

    .top-nav {
        margin: 16px 0 0;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
    }

    .nav-btn {
        background: rgba(255, 255, 255, 0.16);
        color: #fff;
        padding: 8px 14px;
        border-radius: 12px;
        text-decoration: none;
        font-weight: 600;
        border: 1px solid rgba(255, 255, 255, 0.25);
        transition: transform 0.15s, box-shadow 0.15s, background 0.15s;
    }

    .nav-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
        background: rgba(255, 255, 255, 0.22);
    }

    .nav-btn.active-nav {
        background: #ffffff;
        color: #764ba2;
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
    }

    .nav-btn.logout {
        background: #e74c3c;
        border-color: rgba(255, 255, 255, 0.25);
    }

    .nav-btn.logout:hover {
        background: #c0392b;
    }

    .game-container {
        display: flex;
        gap: 20px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .left-panel {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .info-box {
        background: rgba(255, 255, 255, 0.9);

        /* Evitar scroll con flechas y espacio durante el juego */
        html, body {
            overscroll-behavior: contain;
        }
        padding: 15px;
        border-radius: 10px;
        min-width: 150px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .info-box h3 {
        margin: 0 0 10px 0;
        color: #667eea;
        font-size: 16px;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .score-display {
        font-size: 32px;
        font-weight: bold;
        color: #764ba2;
    }

    .level-display {
        font-size: 24px;
        font-weight: bold;
        color: #667eea;
    }

    .lines-display {
        font-size: 20px;
        color: #555;
    }

    .hold-canvas {
        background: #222;
        display: block;
        border-radius: 5px;
    }

    .game-board {
        background: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    #tetris {
        background: #222;
        display: block;
        border-radius: 5px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .right-panel {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .next-canvas {
        background: #222;
        display: block;
        border-radius: 5px;
    }

    .controls {
        background: rgba(255, 255, 255, 0.9);
        padding: 15px;
        border-radius: 10px;
        font-size: 14px;
        line-height: 1.8;
    }

    .controls h3 {
        margin: 0 0 10px 0;
        color: #667eea;
    }

    .controls p {
        margin: 5px 0;
        color: #555;
    }

    /* Leaderboard */
    .leaderboard ol { margin: 0; padding-left: 18px; }
    .leaderboard li { padding: 6px 0; border-bottom: 1px solid #eee; color: #333; font-weight:600; }
    .leaderboard li span.points { float: right; color: #667eea; font-weight:700; }
    .leaderboard p#leaderboardStatus { clear:both; }
    

    .controls strong {
        color: #764ba2;
        display: inline-block;
        width: 100px;
    }

    .game-over-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    .game-over-box {
        background: white;
        padding: 40px;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .game-over-box h2 {
        color: #764ba2;
        margin: 0 0 20px 0;
        font-size: 36px;
    }

    .game-over-box p {
        color: #555;
        font-size: 20px;
        margin: 10px 0;
    }

    .restart-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 15px 40px;
        font-size: 18px;
        border-radius: 25px;
        cursor: pointer;
        margin-top: 20px;
        transition: transform 0.2s;
    }

    .restart-btn:hover {
        transform: scale(1.05);
    }

    .paused-overlay {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 30px 60px;
        border-radius: 15px;
        font-size: 32px;
        font-weight: bold;
        z-index: 999;
    }
</style>

<div class="top-nav">
    <a class="nav-btn" href="{{ path('app_home') }}">← Inicio</a>
    <a class="nav-btn{% if app.request.attributes.get('_route') == 'app_game1' %} active-nav{% endif %}" href="{{ path('app_game1') }}">Juego 1</a>
    <a class="nav-btn{% if app.request.attributes.get('_route') == 'app_game2' %} active-nav{% endif %}" href="{{ path('app_game2') }}">Juego 2</a>
    <a class="nav-btn{% if app.request.attributes.get('_route') == 'app_game3' %} active-nav{% endif %}" href="{{ path('app_game3') }}">Juego 3</a>
    <a class="nav-btn{% if app.request.attributes.get('_route') == 'app_game4' %} active-nav{% endif %}" href="{{ path('app_game4') }}">Juego 4</a>
    <a class="nav-btn{% if app.request.attributes.get('_route') == 'app_game5' %} active-nav{% endif %}" href="{{ path('app_game5') }}">Juego 5</a>
    <a class="nav-btn{% if app.request.attributes.get('_route') == 'app_game6' %} active-nav{% endif %}" href="{{ path('app_game6') }}">Juego 6</a>
    {% if is_granted('ROLE_ADMIN') %}
    <a class="nav-btn" href="{{ path('app_admin') }}">Admin</a>
    {% endif %}
    <a class="nav-btn logout" href="{{ path('app_logout') }}">Cerrar sesión</a>
</div>

<div class="game-container">
    <div class="left-panel">
        {% if user %}
        <div class="info-box">
            <h3>Player</h3>
            <div style="font-size: 16px; color: #555; font-weight: bold;">{{ user.nombre }}</div>
            <div style="font-size: 12px; color: #888; margin-top: 5px;">{{ user.email }}</div>
        </div>
        {% endif %}
        <div class="info-box">
            <h3>Score</h3>
            <div class="score-display" id="score">0</div>
        </div>
        <div class="info-box">
            <h3>Level</h3>
            <div class="level-display" id="level">1</div>
        </div>
        <div class="info-box">
            <h3>Lines</h3>
            <div class="lines-display" id="lines">0</div>
        </div>
        <div class="info-box">
            <h3>Hold (C)</h3>
            <canvas id="holdCanvas" width="120" height="80" class="hold-canvas"></canvas>
        </div>
    </div>

    <div class="game-board">
        <canvas id="tetris" width="300" height="600"></canvas>
        <div class="paused-overlay" id="pausedOverlay">PAUSED</div>
    </div>

    <div class="right-panel">
        <div class="info-box">
            <h3>Next</h3>
            <canvas id="nextCanvas" width="120" height="240" class="next-canvas"></canvas>
        </div>
        <div class="controls">
            <h3>Controls</h3>
            <p><strong>← →</strong> Move</p>
            <p><strong>↓</strong> Soft Drop</p>
            <p><strong>↑</strong> Rotate</p>
            <p><strong>Space</strong> Hard Drop</p>
            <p><strong>C</strong> Hold/Swap</p>
            <p><strong>P</strong> Pause</p>
        </div>
        <div class="info-box leaderboard">
            <h3>Top 10</h3>
            {% if user %}
            <ol id="leaderboardList" style="padding-left:18px; margin:0;">
                <li>Cargando...</li>
            </ol>
            <p id="leaderboardStatus" style="font-size:12px;color:#888;margin-top:8px;"></p>
            {% else %}
            <p style="color:#f39c12; font-weight:600;">⚠ Inicia sesión para ver el ranking</p>
            {% endif %}
        </div>
    </div> 
</div>

<div class="game-over-overlay" id="gameOverOverlay">
    <div class="game-over-box">
        <h2>GAME OVER!</h2>
        <p>Score: <span id="finalScore">0</span></p>
        <p>Level: <span id="finalLevel">1</span></p>
        <p>Lines: <span id="finalLines">0</span></p>
        <p id="saveStatus" style="color: #667eea; font-size: 16px; margin: 10px 0;">Guardando puntuación...</p>
        <button class="restart-btn" onclick="location.reload()">Play Again</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');
    const holdCanvas = document.getElementById('holdCanvas');
    const holdCtx = holdCanvas.getContext('2d');

    const ROWS = 20;
    const COLS = 10;
    const BLOCK_SIZE = 30;
    const COLORS = [
        '#000000', // 0 - empty
        '#00f0f0', // 1 - I (cyan)
        '#f0f000', // 2 - O (yellow)
        '#a000f0', // 3 - T (purple)
        '#00f000', // 4 - S (green)
        '#f00000', // 5 - Z (red)
        '#0000f0', // 6 - J (blue)
        '#f0a000'  // 7 - L (orange)
    ];

    const SHAPES = [
        [[1,1,1,1]], // I
        [[1,1],[1,1]], // O
        [[0,1,0],[1,1,1]], // T
        [[0,1,1],[1,1,0]], // S
        [[1,1,0],[0,1,1]], // Z
        [[1,0,0],[1,1,1]], // J
        [[0,0,1],[1,1,1]]  // L
    ];

    let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let score = 0;
    let lines = 0;
    let level = 1;
    let gameOver = false;
    let isPaused = false;
    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;

    let currentPiece = null;
    let nextPieces = [];
    let holdPiece = null;
    let canHold = true;

    class Piece {
        constructor(shape, color) {
            this.shape = shape;
            this.color = color;
            this.x = Math.floor(COLS / 2) - Math.floor(shape[0].length / 2);
            this.y = 0;
        }

        clone() {
            const cloned = new Piece(this.shape, this.color);
            cloned.x = this.x;
            cloned.y = this.y;
            return cloned;
        }
    }

    function createPiece() {
        const index = Math.floor(Math.random() * SHAPES.length);
        return new Piece(SHAPES[index], index + 1);
    }

    function initNextPieces() {
        for (let i = 0; i < 3; i++) {
            nextPieces.push(createPiece());
        }
    }

    function getNextPiece() {
        currentPiece = nextPieces.shift();
        nextPieces.push(createPiece());
        canHold = true;
    }

    function drawBlock(ctx, x, y, color, size = BLOCK_SIZE) {
        ctx.fillStyle = COLORS[color];
        ctx.fillRect(x * size, y * size, size, size);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x * size, y * size, size, size);
        
        // Add highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(x * size, y * size, size / 3, size / 3);
    }

    function drawBoard() {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                if (board[row][col]) {
                    drawBlock(ctx, col, row, board[row][col]);
                }
            }
        }
    }

    function drawPiece(piece, context = ctx, offsetX = 0, offsetY = 0, blockSize = BLOCK_SIZE) {
        piece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    drawBlock(context, piece.x + x + offsetX, piece.y + y + offsetY, piece.color, blockSize);
                }
            });
        });
    }

    function drawGhost() {
        const ghost = currentPiece.clone();
        while (!collision(ghost)) {
            ghost.y++;
        }
        ghost.y--;
        
        ghost.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fillRect((ghost.x + x) * BLOCK_SIZE, (ghost.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect((ghost.x + x) * BLOCK_SIZE, (ghost.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                }
            });
        });
    }

    function drawNextPieces() {
        nextCtx.fillStyle = '#222';
        nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
        
        nextPieces.forEach((piece, index) => {
            const tempPiece = piece.clone();
            tempPiece.x = 1;
            tempPiece.y = index * 2.5;
            drawPiece(tempPiece, nextCtx, 0, 0, 24);
        });
    }

    function drawHoldPiece() {
        holdCtx.fillStyle = '#222';
        holdCtx.fillRect(0, 0, holdCanvas.width, holdCanvas.height);
        
        if (holdPiece) {
            const tempPiece = holdPiece.clone();
            tempPiece.x = 1;
            tempPiece.y = 1;
            drawPiece(tempPiece, holdCtx, 0, 0, 24);
        }
    }

    function collision(piece) {
        for (let y = 0; y < piece.shape.length; y++) {
            for (let x = 0; x < piece.shape[y].length; x++) {
                if (piece.shape[y][x]) {
                    const newX = piece.x + x;
                    const newY = piece.y + y;
                    
                    if (newX < 0 || newX >= COLS || newY >= ROWS) {
                        return true;
                    }
                    
                    if (newY >= 0 && board[newY][newX]) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function merge() {
        currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    const boardY = currentPiece.y + y;
                    const boardX = currentPiece.x + x;
                    if (boardY >= 0) {
                        board[boardY][boardX] = currentPiece.color;
                    }
                }
            });
        });
    }

    function rotate() {
        const rotated = currentPiece.shape[0].map((_, i) =>
            currentPiece.shape.map(row => row[i]).reverse()
        );
        
        const previousShape = currentPiece.shape;
        currentPiece.shape = rotated;
        
        // Wall kick
        let offset = 0;
        while (collision(currentPiece)) {
            currentPiece.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > currentPiece.shape[0].length) {
                currentPiece.shape = previousShape;
                return;
            }
        }
    }

    function clearLines() {
        let linesCleared = 0;
        
        outer: for (let row = ROWS - 1; row >= 0; row--) {
            for (let col = 0; col < COLS; col++) {
                if (!board[row][col]) {
                    continue outer;
                }
            }
            
            board.splice(row, 1);
            board.unshift(Array(COLS).fill(0));
            linesCleared++;
            row++;
        }
        
        if (linesCleared > 0) {
            lines += linesCleared;
            score += [0, 100, 300, 500, 800][linesCleared] * level;
            level = Math.floor(lines / 10) + 1;
            dropInterval = Math.max(100, 1000 - (level - 1) * 100);
            updateDisplay();
        }
    }

    function drop() {
        currentPiece.y++;
        if (collision(currentPiece)) {
            currentPiece.y--;
            merge();
            clearLines();
            getNextPiece();
            
            if (collision(currentPiece)) {
                gameOver = true;
                showGameOver();
            }
        }
        dropCounter = 0;
    }

    function hardDrop() {
        while (!collision(currentPiece)) {
            currentPiece.y++;
            score += 2;
        }
        currentPiece.y--;
        drop();
        updateDisplay();
    }

    function holdCurrentPiece() {
        if (!canHold) return;
        
        canHold = false;
        
        if (holdPiece === null) {
            holdPiece = new Piece(currentPiece.shape, currentPiece.color);
            getNextPiece();
        } else {
            const temp = new Piece(holdPiece.shape, holdPiece.color);
            holdPiece = new Piece(currentPiece.shape, currentPiece.color);
            currentPiece = temp;
            currentPiece.x = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
            currentPiece.y = 0;
        }
        
        drawHoldPiece();
    }

    function moveLeft() {
        currentPiece.x--;
        if (collision(currentPiece)) {
            currentPiece.x++;
        }
    }

    function moveRight() {
        currentPiece.x++;
        if (collision(currentPiece)) {
            currentPiece.x--;
        }
    }

    function updateDisplay() {
        document.getElementById('score').textContent = score;
        document.getElementById('level').textContent = level;
        document.getElementById('lines').textContent = lines;
    }

    function showGameOver() {
        document.getElementById('finalScore').textContent = score;
        document.getElementById('finalLevel').textContent = level;
        document.getElementById('finalLines').textContent = lines;
        document.getElementById('gameOverOverlay').style.display = 'flex';
        
        // Guardar la partida en la base de datos
        saveGameScore();
    }

    function saveGameScore() {
        {% if user %}
        const data = {
            api_key: 'ABCDEFGHIJK1234567890',
            token_usuario: '{{ user.email }}',
            token_juego: 'TETRIS_GAME_TOKEN_002',
            puntos: score.toString()
        };

        const saveStatus = document.getElementById('saveStatus');
        
        fetch('{{ path("api_juego_guardar") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify(data)
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Error en el servidor: ' + response.status);
            }
            return response.text();
        })
        .then(text => {
            try {
                return JSON.parse(text);
            } catch (e) {
                console.error('Respuesta del servidor:', text);
                throw new Error('Respuesta inválida del servidor');
            }
        })
        .then(result => {
            console.log(result);
            if (result.success) {
                saveStatus.textContent = '✓ Puntuación guardada correctamente';
                saveStatus.style.color = '#27ae60';
                // Refrescar el ranking
                if (typeof fetchLeaderboard === 'function') fetchLeaderboard();
            } else {
                saveStatus.textContent = '✗ Error al guardar: ' + result.message;
                saveStatus.style.color = '#e74c3c';
            }
        })
        .catch(error => {
            console.error('Error completo:', error);
            saveStatus.textContent = '✗ Error al guardar: ' + error.message;
            saveStatus.style.color = '#e74c3c';
        });
        {% else %}
        const saveStatus = document.getElementById('saveStatus');
        saveStatus.textContent = '⚠ Inicia sesión para guardar tu puntuación';
        saveStatus.style.color = '#f39c12';
        {% endif %}
    }

    function togglePause() {
        isPaused = !isPaused;
        document.getElementById('pausedOverlay').style.display = isPaused ? 'block' : 'none';
    }

    function gameLoop(time = 0) {
        if (gameOver) return;
        
        if (!isPaused) {
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            
            if (dropCounter > dropInterval) {
                drop();
            }
            
            drawBoard();
            drawGhost();
            drawPiece(currentPiece);
            drawNextPieces();
        }
        
        requestAnimationFrame(gameLoop);
    }

    document.addEventListener('keydown', (e) => {
            // Evitar scroll de flechas y espacio
            if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," ","Spacebar"].includes(e.key)) {
                e.preventDefault();
            }
        if (gameOver) return;
        
        if (e.key === 'p' || e.key === 'P') {
            togglePause();
            return;
        }
        
        if (isPaused) return;
        
        switch (e.key) {
            case 'ArrowLeft':
                moveLeft();
                break;
            case 'ArrowRight':
                moveRight();
                break;
            case 'ArrowDown':
                drop();
                score += 1;
                updateDisplay();
                break;
            case 'ArrowUp':
                rotate();
                break;
            case ' ':
                e.preventDefault();
                hardDrop();
                break;
            case 'c':
            case 'C':
                holdCurrentPiece();
                break;
        }
    });

    // Initialize game
    initNextPieces();
    getNextPiece();
    updateDisplay();
    {% if user %}
    // Fetch the leaderboard for this game when a user is present
    function fetchLeaderboard() {
        const data = {
            api_key: 'ABCDEFGHIJK1234567890',
            token_usuario: '{{ user.email }}',
            token_juego: 'TETRIS_GAME_TOKEN_002'
        };

        const listEl = document.getElementById('leaderboardList');
        const statusEl = document.getElementById('leaderboardStatus');
        if (!listEl || !statusEl) return;

        statusEl.textContent = 'Cargando ranking...';

        fetch('{{ path("api_juego") }}', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-Requested-With': 'XMLHttpRequest' },
            body: JSON.stringify(data)
        })
        .then(response => {
            if (!response.ok) throw new Error('Error en el servidor: ' + response.status);
            return response.json();
        })
        .then(result => {
            if (result.success && result.data && result.data['Listado jugadores']) {
                const jugadores = result.data['Listado jugadores'];
                listEl.innerHTML = '';
                if (jugadores.length === 0) {
                    listEl.innerHTML = '<li>No hay resultados</li>';
                } else {
                    jugadores.forEach(j => {
                        const li = document.createElement('li');
                        li.innerHTML = '<span class="player">' + j.jugador + '</span>' + '<span class="points">' + j.Puntos + '</span>';
                        listEl.appendChild(li);
                    });
                }
                statusEl.textContent = '';
            } else {
                statusEl.textContent = 'No hay datos disponibles';
            }
        })
        .catch(err => {
            console.error('Error al cargar ranking:', err);
            statusEl.textContent = 'Error al cargar ranking';
        });
    }

    fetchLeaderboard();
    {% endif %}
    gameLoop();
</script>
{% endblock %}
