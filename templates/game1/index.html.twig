{% extends 'layout.html.twig' %}

{% block title %}Snake Game{% endblock %}

{% block page_content %}
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
    }

    .top-nav {
        margin: 10px 0 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
    }

    .nav-btn {
        background: rgba(255, 255, 255, 0.16);
        color: #fff;
        padding: 8px 14px;
        border-radius: 12px;
        text-decoration: none;
        font-weight: 600;
        border: 1px solid rgba(255, 255, 255, 0.25);
        transition: transform 0.15s, box-shadow 0.15s, background 0.15s;
    }

    .nav-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
        background: rgba(255, 255, 255, 0.22);
    }

    .nav-btn.active-nav {
        background: #ffffff;
        color: #764ba2;
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
    }

    .nav-btn.logout {
        background: #e74c3c;
        border-color: rgba(255, 255, 255, 0.25);
    }

    .nav-btn.logout:hover {
        background: #c0392b;
    }
    
    .game-container {
        background: white;
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        text-align: center;
        max-width: 784px;
        width: 100%;
    }
    
    h1 {
        color: #667eea;
        margin-bottom: 20px;
        font-size: 2.5em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .game-info {
        display: flex;
        justify-content: space-around;
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 15px;
    }
    
    .info-box {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 25px;
        border-radius: 10px;
        min-width: 150px;
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }
    
    .info-box h3 {
        font-size: 0.9em;
        margin-bottom: 5px;
        opacity: 0.9;
    }
    
    .info-box p {
        font-size: 1.8em;
        font-weight: bold;
    }
    
    #gameCanvas {
        border: 4px solid #667eea;
        border-radius: 10px;
        background: #f8f9fa;
        display: block;
        margin: 0 auto 20px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .controls {
        margin-bottom: 20px;
    }
    
    .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 25px;
        font-size: 1.1em;
        cursor: pointer;
        margin: 5px;
        transition: transform 0.2s, box-shadow 0.2s;
        font-weight: bold;
    }
    
    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
    }
    
    .btn:active {
        transform: translateY(0);
    }
    
    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .instructions {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 10px;
        margin-top: 20px;
        text-align: left;
    }
    
    .instructions h3 {
        color: #667eea;
        margin-bottom: 10px;
    }
    
    .instructions ul {
        list-style-position: inside;
        color: #555;
    }
    
    .instructions li {
        margin: 5px 0;
    }
    
    .game-over {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        display: none;
        z-index: 1000;
        text-align: center;
    }
    
    .game-over.show {
        display: block;
        animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
        from {
            transform: translate(-50%, -60%);
            opacity: 0;
        }
        to {
            transform: translate(-50%, -50%);
            opacity: 1;
        }
    }
    
    .game-over h2 {
        color: #e74c3c;
        font-size: 2.5em;
        margin-bottom: 20px;
    }
    
    .game-over .final-score {
        font-size: 1.5em;
        color: #667eea;
        margin-bottom: 20px;
    }
    
    .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        z-index: 999;
    }

    /* Leaderboard styles (match Tetris) */
    .leaderboard ol { margin: 0; padding-left: 18px; }
    .leaderboard li { padding: 6px 0; border-bottom: 1px solid #eee; color: #333; font-weight:600; }
    .leaderboard li span.points { float: right; color: #667eea; font-weight:700; }
    
    .overlay.show {
        display: block;
    }
</style>

<div class="overlay" id="overlay"></div>

<div class="top-nav">
    <a class="nav-btn" href="{{ path('app_home') }}">‚Üê Inicio</a>
    <a class="nav-btn{% if app.request.attributes.get('_route') == 'app_game1' %} active-nav{% endif %}" href="{{ path('app_game1') }}">Juego 1</a>
    <a class="nav-btn{% if app.request.attributes.get('_route') == 'app_game2' %} active-nav{% endif %}" href="{{ path('app_game2') }}">Juego 2</a>
    <a class="nav-btn{% if app.request.attributes.get('_route') == 'app_game3' %} active-nav{% endif %}" href="{{ path('app_game3') }}">Juego 3</a>
    <a class="nav-btn{% if app.request.attributes.get('_route') == 'app_game4' %} active-nav{% endif %}" href="{{ path('app_game4') }}">Juego 4</a>
    <a class="nav-btn{% if app.request.attributes.get('_route') == 'app_game5' %} active-nav{% endif %}" href="{{ path('app_game5') }}">Juego 5</a>
    <a class="nav-btn{% if app.request.attributes.get('_route') == 'app_game6' %} active-nav{% endif %}" href="{{ path('app_game6') }}">Juego 6</a>
    {% if is_granted('ROLE_ADMIN') %}
    <a class="nav-btn" href="{{ path('app_admin') }}">Admin</a>
    {% endif %}
    <a class="nav-btn logout" href="{{ path('app_logout') }}">Cerrar sesi√≥n</a>
</div>

<div class="game-over" id="gameOverModal">
    <h2>¬°Game Over! üéÆ</h2>
    <p class="final-score">Puntuaci√≥n Final: <span id="finalScore">0</span></p>
    <p id="saveStatus" style="color: #667eea; font-size: 0.9em; margin: 10px 0;"></p>
    <button class="btn" onclick="restartGame()">Jugar de Nuevo</button>
</div>

<div class="game-container">
    <h1>üêç Snake Game</h1>
    
    <div class="game-info">
        <div class="info-box">
            <h3>Puntuaci√≥n</h3>
            <p id="score">0</p>
        </div>
        <div class="info-box">
            <h3>R√©cord</h3>
            <p id="highScore">0</p>
        </div>
        <div class="info-box">
            <h3>Nivel</h3>
            <p id="level">1</p>
        </div>
    </div>
    
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    
    <div class="controls">
        <button class="btn" id="startBtn" onclick="startGame()">Iniciar Juego</button>
        <button class="btn" id="pauseBtn" onclick="togglePause()" disabled>Pausar</button>
    </div>
    
    <div class="instructions">
        <h3>üìñ Instrucciones:</h3>
        <ul>
            <li>Usa las flechas del teclado o WASD para mover la serpiente</li>
            <li>Come las manzanas rojas para crecer y ganar puntos</li>
            <li>Evita chocar con las paredes o contigo mismo</li>
            <li>Cada 5 puntos subes de nivel y el juego se acelera</li>
            <li>Presiona ESPACIO para pausar/reanudar</li>
        </ul>
    </div>

    <div class="info-box leaderboard" style="margin-top:20px; max-width:650px; width:100%;">
        <h3>Top 10</h3>
        {% if user %}
        <ol id="leaderboardList" style="padding-left:18px; margin:0;">
            <li>Cargando...</li>
        </ol>
        <p id="leaderboardStatus" style="font-size:12px;color:#888;margin-top:8px;"></p>
        {% else %}
        <p style="color:#f39c12; font-weight:600;">‚ö† Inicia sesi√≥n para ver el ranking</p>
        {% endif %}
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const highScoreElement = document.getElementById('highScore');
const levelElement = document.getElementById('level');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const gameOverModal = document.getElementById('gameOverModal');
const overlay = document.getElementById('overlay');
const finalScoreElement = document.getElementById('finalScore');

const gridSize = 20;
const tileCount = canvas.width / gridSize;

let snake = [{ x: 10, y: 10 }];
let food = { x: 15, y: 15 };
let dx = 0;
let dy = 0;
let score = 0;
let highScore = localStorage.getItem('snakeHighScore') || 0;
let level = 1;
let gameLoop = null;
let gameSpeed = 150;
let isPaused = false;
let gameStarted = false;

highScoreElement.textContent = highScore;

function drawGame() {
    if (isPaused) return;
    
    clearCanvas();
    moveSnake();
    
    if (checkCollision()) {
        gameOver();
        return;
    }
    
    if (checkFoodCollision()) {
        score += 10;
        scoreElement.textContent = score;
        
        if (score > highScore) {
            highScore = score;
            highScoreElement.textContent = highScore;
            localStorage.setItem('snakeHighScore', highScore);
        }
        
        // Aumentar nivel cada 5 comidas
        if (score % 50 === 0) {
            level++;
            levelElement.textContent = level;
            gameSpeed = Math.max(50, gameSpeed - 10);
            clearInterval(gameLoop);
            gameLoop = setInterval(drawGame, gameSpeed);
        }
        
        generateFood();
    } else {
        snake.pop();
    }
    
    drawSnake();
    drawFood();
}

function clearCanvas() {
    ctx.fillStyle = '#f8f9fa';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Dibujar grid
    ctx.strokeStyle = '#e9ecef';
    ctx.lineWidth = 1;
    for (let i = 0; i <= tileCount; i++) {
        ctx.beginPath();
        ctx.moveTo(i * gridSize, 0);
        ctx.lineTo(i * gridSize, canvas.height);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, i * gridSize);
        ctx.lineTo(canvas.width, i * gridSize);
        ctx.stroke();
    }
}

function drawSnake() {
    snake.forEach((segment, index) => {
        if (index === 0) {
            // Cabeza con gradiente
            const gradient = ctx.createRadialGradient(
                segment.x * gridSize + gridSize / 2,
                segment.y * gridSize + gridSize / 2,
                0,
                segment.x * gridSize + gridSize / 2,
                segment.y * gridSize + gridSize / 2,
                gridSize
            );
            gradient.addColorStop(0, '#4CAF50');
            gradient.addColorStop(1, '#2E7D32');
            ctx.fillStyle = gradient;
        } else {
            // Cuerpo
            ctx.fillStyle = '#66BB6A';
        }
        
        ctx.fillRect(
            segment.x * gridSize + 1,
            segment.y * gridSize + 1,
            gridSize - 2,
            gridSize - 2
        );
        
        // Bordes redondeados
        ctx.strokeStyle = '#2E7D32';
        ctx.lineWidth = 2;
        ctx.strokeRect(
            segment.x * gridSize + 1,
            segment.y * gridSize + 1,
            gridSize - 2,
            gridSize - 2
        );
        
        // Ojos en la cabeza
        if (index === 0) {
            ctx.fillStyle = 'white';
            const eyeSize = 4;
            const eyeOffset = 6;
            
            if (dx !== 0 || dy !== 0) {
                if (dx > 0) { // Derecha
                    ctx.fillRect(segment.x * gridSize + gridSize - eyeOffset - eyeSize, segment.y * gridSize + 4, eyeSize, eyeSize);
                    ctx.fillRect(segment.x * gridSize + gridSize - eyeOffset - eyeSize, segment.y * gridSize + gridSize - 8, eyeSize, eyeSize);
                } else if (dx < 0) { // Izquierda
                    ctx.fillRect(segment.x * gridSize + eyeOffset, segment.y * gridSize + 4, eyeSize, eyeSize);
                    ctx.fillRect(segment.x * gridSize + eyeOffset, segment.y * gridSize + gridSize - 8, eyeSize, eyeSize);
                } else if (dy > 0) { // Abajo
                    ctx.fillRect(segment.x * gridSize + 4, segment.y * gridSize + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
                    ctx.fillRect(segment.x * gridSize + gridSize - 8, segment.y * gridSize + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
                } else if (dy < 0) { // Arriba
                    ctx.fillRect(segment.x * gridSize + 4, segment.y * gridSize + eyeOffset, eyeSize, eyeSize);
                    ctx.fillRect(segment.x * gridSize + gridSize - 8, segment.y * gridSize + eyeOffset, eyeSize, eyeSize);
                }
            }
        }
    });
}

function drawFood() {
    // Manzana roja con gradiente
    const gradient = ctx.createRadialGradient(
        food.x * gridSize + gridSize / 2,
        food.y * gridSize + gridSize / 2,
        0,
        food.x * gridSize + gridSize / 2,
        food.y * gridSize + gridSize / 2,
        gridSize
    );
    gradient.addColorStop(0, '#FF5252');
    gradient.addColorStop(1, '#D32F2F');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(
        food.x * gridSize + gridSize / 2,
        food.y * gridSize + gridSize / 2,
        gridSize / 2 - 2,
        0,
        Math.PI * 2
    );
    ctx.fill();
    
    // Hoja de la manzana
    ctx.fillStyle = '#4CAF50';
    ctx.beginPath();
    ctx.arc(
        food.x * gridSize + gridSize / 2 + 3,
        food.y * gridSize + gridSize / 2 - 6,
        3,
        0,
        Math.PI * 2
    );
    ctx.fill();
}

function moveSnake() {
    const head = { x: snake[0].x + dx, y: snake[0].y + dy };
    snake.unshift(head);
}

function checkCollision() {
    const head = snake[0];
    
    // Colisi√≥n con paredes
    if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
        return true;
    }
    
    // Colisi√≥n consigo mismo
    for (let i = 1; i < snake.length; i++) {
        if (head.x === snake[i].x && head.y === snake[i].y) {
            return true;
        }
    }
    
    return false;
}

function checkFoodCollision() {
    return snake[0].x === food.x && snake[0].y === food.y;
}

function generateFood() {
    let newFood;
    do {
        newFood = {
            x: Math.floor(Math.random() * tileCount),
            y: Math.floor(Math.random() * tileCount)
        };
    } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
    
    food = newFood;
}

function startGame() {
    if (gameStarted) return;
    
    snake = [{ x: 10, y: 10 }];
    dx = 1;
    dy = 0;
    score = 0;
    level = 1;
    gameSpeed = 150;
    isPaused = false;
    gameStarted = true;
    
    scoreElement.textContent = score;
    levelElement.textContent = level;
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    pauseBtn.textContent = 'Pausar';
    
    generateFood();
    gameLoop = setInterval(drawGame, gameSpeed);
}

function togglePause() {
    if (!gameStarted) return;
    
    isPaused = !isPaused;
    pauseBtn.textContent = isPaused ? 'Reanudar' : 'Pausar';
    
    if (!isPaused) {
        drawGame();
    }
}

function gameOver() {
    clearInterval(gameLoop);
    gameStarted = false;
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    
    finalScoreElement.textContent = score;
    
    // Guardar la partida
    saveGame(score);
    
    gameOverModal.classList.add('show');
    overlay.classList.add('show');
}

function restartGame() {
    gameOverModal.classList.remove('show');
    overlay.classList.remove('show');
    startGame();
}

// Funci√≥n para guardar la partida en la base de datos
// Se env√≠a al endpoint /api/juego/guardar con los datos del juego
async function saveGame(puntos) {
    const saveStatusElement = document.getElementById('saveStatus');
    
    {% if user %}
    const apiKey = '{{ api_key }}';
    const gameToken = '{{ game_token }}';
    const userEmail = '{{ user.email }}';
    
    console.log('Guardando partida...', {
        puntos: puntos,
        usuario: userEmail,
        juego: gameToken
    });
    
    saveStatusElement.textContent = 'üíæ Guardando partida...';
    saveStatusElement.style.color = '#667eea';
    
    const data = {
        api_key: apiKey,
        token_usuario: userEmail,
        token_juego: gameToken,
        puntos: puntos
    };
    
    try {
        const response = await fetch('/api/juego/guardar', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data)
        });
        
        console.log('Status de respuesta:', response.status);
        console.log('Headers:', response.headers.get('content-type'));
        
        // Obtener el texto de la respuesta primero
        const responseText = await response.text();
        console.log('Respuesta raw:', responseText.substring(0, 500));
        
        // Intentar parsear como JSON
        let result;
        try {
            result = JSON.parse(responseText);
        } catch (e) {
            console.error('Error al parsear JSON:', e);
            console.error('Respuesta completa:', responseText);
            throw new Error('El servidor no devolvi√≥ JSON v√°lido');
        }
        
        console.log('Respuesta del servidor:', result);
        
        if (result.success) {
            console.log('‚úÖ Partida guardada exitosamente!');
            saveStatusElement.textContent = '‚úÖ ¬°Partida guardada correctamente!';
            saveStatusElement.style.color = '#4CAF50';
            
            // Actualizar el top10 exactamente igual que en Tetris
            if (typeof fetchLeaderboard === 'function') {
                try { fetchLeaderboard(); } catch (e) { console.warn('No se pudo refrescar el Top10:', e); }
            }
        } else {
            console.error('‚ùå Error al guardar partida:', result.message);
            console.error('Detalles:', result.data);
            saveStatusElement.textContent = '‚ö†Ô∏è Error al guardar: ' + result.message;
            saveStatusElement.style.color = '#e74c3c';
        }
    } catch (error) {
        console.error('‚ùå Error en la petici√≥n:', error);
        saveStatusElement.textContent = '‚ùå Error de conexi√≥n al guardar';
        saveStatusElement.style.color = '#e74c3c';
    }
    {% else %}
    console.warn('‚ö†Ô∏è Usuario no autenticado. No se puede guardar la partida.');
    saveStatusElement.textContent = '‚ö†Ô∏è Debes iniciar sesi√≥n para guardar';
    saveStatusElement.style.color = '#e74c3c';
    {% endif %}
}

document.addEventListener('keydown', (e) => {
    // Evitar que las flechas/espacio hagan scroll en la p√°gina
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " ", "Spacebar"].includes(e.key)) {
        e.preventDefault();
    }

    if (!gameStarted) return;
    
    if (e.key === ' ') {
        e.preventDefault();
        togglePause();
        return;
    }
    
    if (isPaused) return;
    
    switch(e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
            if (dy === 0) { dx = 0; dy = -1; }
            break;
        case 'ArrowDown':
        case 's':
        case 'S':
            if (dy === 0) { dx = 0; dy = 1; }
            break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
            if (dx === 0) { dx = -1; dy = 0; }
            break;
        case 'ArrowRight':
        case 'd':
        case 'D':
            if (dx === 0) { dx = 1; dy = 0; }
            break;
    }
});

// Dibujar estado inicial
clearCanvas();
drawSnake();
drawFood();

{% if user %}
    // Fetch leaderboard for Snake
    function fetchLeaderboard() {
        const data = {
            api_key: '{{ api_key }}',
            token_usuario: '{{ user.email }}',
            token_juego: '{{ game_token }}'
        };

        const listEl = document.getElementById('leaderboardList');
        const statusEl = document.getElementById('leaderboardStatus');
        if (!listEl || !statusEl) return;

        statusEl.textContent = 'Cargando ranking...';

        fetch('{{ path("api_juego") }}', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-Requested-With': 'XMLHttpRequest' },
            body: JSON.stringify(data)
        })
        .then(response => {
            if (!response.ok) throw new Error('Error en el servidor: ' + response.status);
            return response.json();
        })
        .then(result => {
            if (result.success && result.data && result.data['Listado jugadores']) {
                const jugadores = result.data['Listado jugadores'];
                listEl.innerHTML = '';
                if (jugadores.length === 0) {
                    listEl.innerHTML = '<li>No hay resultados</li>';
                } else {
                    jugadores.forEach(j => {
                        const li = document.createElement('li');
                        li.innerHTML = '<span class="player">' + j.jugador + '</span>' + '<span class="points">' + j.Puntos + '</span>';
                        listEl.appendChild(li);
                    });
                }
                statusEl.textContent = '';
            } else {
                statusEl.textContent = 'No hay datos disponibles';
            }
        })
        .catch(err => {
            console.error('Error al cargar ranking:', err);
            statusEl.textContent = 'Error al cargar ranking';
        });
    }

    fetchLeaderboard();
{% endif %}
</script>
{% endblock %}
